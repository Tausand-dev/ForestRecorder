/*----------------------------------------------------------------------*/
/* FatFs sample project for Atmel AVR                (C)ChaN, 2018      */
/*----------------------------------------------------------------------*/


#include <avr/io.h>
#include <avr/interrupt.h>
#include <string.h>
#include "xitoa.h"
#include "ff.h"
#include "diskio.h"


FUSES = {0xF7, 0x91, 0xFC};		/* ATmega1284p fuses: Low, High, Extended. */
/* This is the fuse settings for this project. The fuse bits will be included
in the output hex file with program code. However some old flash programmers
cannot load the fuse bits from hex file. If it is the case, remove this line
and use these values to program the fuse bits. */


BYTE Buff[4096];	/* Working buffer */

FATFS FatFs[2];		/* Filesystem object for each logical drive */
FIL File[2];		/* File object */
DIR Dir;			/* Directory object */
FILINFO Finfo;
DWORD AccSize;				/* Work register for fs command */
WORD AccFiles, AccDirs;

BYTE RtcOk;				/* RTC is available */
volatile UINT Timer;	/* Performance timer (100Hz increment) */



/*--------------------------------------------------------------------*/
/* User Provided Timer Function for FatFs module                      */
/*--------------------------------------------------------------------*/
/* This is a real time clock service to be called from FatFs module.  */
/* Any valid time must be returned even if the system does not        */
/* support a real time clock. This is not required when FatFs is      */
/* configured for FF_FS_READONLY or FF_FS_NORTC = 1.                  */
/*--------------------------------------------------------------------*/


DWORD get_fattime (void)
{
	// RTC rtc;
	//
	//
	// if (!RtcOk) return 0;
	//
	// /* Get local time */
	// rtc_gettime(&rtc);
	//
	// /* Pack date and time into a DWORD variable */
	// return	  ((DWORD)(rtc.year - 1980) << 25)
	// 		| ((DWORD)rtc.month << 21)
	// 		| ((DWORD)rtc.mday << 16)
	// 		| ((DWORD)rtc.hour << 11)
	// 		| ((DWORD)rtc.min << 5)
	// 		| ((DWORD)rtc.sec >> 1);

		return 0;
}



/*---------------------------------------------------------*/
/* 100Hz timer interrupt generated by OC0A                 */
/*---------------------------------------------------------*/


ISR(TIMER0_COMPA_vect)
{
	Timer++;			/* Performance counter for this module */
	disk_timerproc();	/* Drive timer procedure of low level disk I/O module */
}



/*--------------------------------------------------------------------------*/
/* Monitor                                                                  */


static
void put_dump (const BYTE *buff, DWORD ofs, BYTE cnt)
{
	BYTE i;


	xprintf(PSTR("%08lX:"), ofs);

	for(i = 0; i < cnt; i++)
		xprintf(PSTR(" %02X"), buff[i]);

	xputc(' ');
	for(i = 0; i < cnt; i++)
		xputc((buff[i] >= ' ' && buff[i] <= '~') ? buff[i] : '.');

	xputc('\n');
}


static
FRESULT scan_files (
	char* path		/* Pointer to the working buffer with start path */
)
{
	DIR dirs;
	FRESULT fr;
	int i;

	fr = f_opendir(&dirs, path);
	if (fr == FR_OK) {
		while (((fr = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
			if (Finfo.fattrib & AM_DIR) {
				AccDirs++;
				i = strlen(path);
				path[i] = '/'; strcpy(path+i+1, Finfo.fname);
				fr = scan_files(path);
				path[i] = 0;
				if (fr != FR_OK) break;
			} else {
//				xprintf(PSTR("%s/%s\n"), path, Finfo.fname);
				AccFiles++;
				AccSize += Finfo.fsize;
			}
		}
	}

	return fr;
}



static
void put_rc (FRESULT rc)
{
	const prog_char *p;
	static const prog_char str[] =
		"OK\0DISK_ERR\0INT_ERR\0NOT_READY\0NO_FILE\0NO_PATH\0INVALID_NAME\0"
		"DENIED\0EXIST\0INVALID_OBJECT\0WRITE_PROTECTED\0INVALID_DRIVE\0"
		"NOT_ENABLED\0NO_FILE_SYSTEM\0MKFS_ABORTED\0TIMEOUT\0LOCKED\0"
		"NOT_ENOUGH_CORE\0TOO_MANY_OPEN_FILES\0";
	FRESULT i;

	for (p = str, i = 0; i != rc && pgm_read_byte_near(p); i++) {
		while(pgm_read_byte_near(p++));
	}
	xprintf(PSTR("rc=%u FR_%S\n"), rc, p);
}




static
void ioinit (void)
{
	/* Start 100Hz system timer with TC0 */
	OCR0A = F_CPU / 1024 / 100 - 1;
	TCCR0A = _BV(WGM01);
	TCCR0B = 0b101;
	TIMSK0 = _BV(OCIE0A);

	sei();
}



/*-----------------------------------------------------------------------*/
/* Main                                                                  */


int main (void)
{
	ioinit();				/* Initialize port settings and start system timer process */
// #ifdef DRV_CFC
// 	xprintf(PSTR("CFC ==> %u\n"), DRV_CFC);
// #endif
// #ifdef DRV_MMC
// 	xprintf(PSTR("MMC ==> %u\n"), DRV_MMC);
	return 0;
}
